The Design Draft Of Human Programming Language
==================================
Human 编程语言设计草案。

目标
----------------------------------
爱因斯坦说过一句话, "这个世界最不可理解的就是它竟然是可以理解的"。我也是抱着类似的信念, 挖掘
和思索人类思维的本质, 去设计一门对计算机语言用户来说易于思维和理解的编程语言。"易于思维"意味
着方便用户在具体业务和计算机多层次抽象之间的映射, 同时也包含着创造。"易于理解"意味着方便某具
体项目的相关用户之间的协作, 同时也包含着传递。

思维
----------------------------------
### 思维是什么?
或者说究竟什么是自我, 这个问题已经被众多哲学家和心理学家等各种家所探讨, 我也不知道是什么, 姑
且可以认为是某种神秘之物(概念来自于哲学家维特根斯坦), 人们通常说的自由意志也来自于此。人类思
维之于计算机, 我们唯一关心的是两者应该如何相处, 尽可能地发挥两者的最大效用。

### 思维有什么用?
思维给我们带来了两件东西, 其一是上下文, 其二是美。

上下文是人类思维的特征, 比如日常交流里

思维的局限性导致了多学科的出现，也即是人类社会的繁荣。

上下文的例子随处可见, 日常交流, 文学作品,
既是优点，也是缺点。美驱动着上下文。
编程语言里。
我认为这是

* 人类思维用语言来表达，因此语言体现了人类思维。编程中的例子可见 "Context"。

人类思维等价

程序等价

现实问题
----------------------------------
* 因为 Human程序语言 是依据人类思维 而设计的，所以它可以辅助人类编程，尽可能降低程序复
  杂度。

Thoughts
----------------------------------
* 写程序不单单是和机器沟通，更是和未来要看这段程序的人沟通的。试想要给另一个人讲解代码
   ，首先你自己会在代码的每个层次上广度优先讲解，其次针对对方的提问，这提问却总是在一
  个层次上的（如果对方提了两个层次，你也会给对方分成两个层次讲），所以这一个层次的相关
  代码以某种方式集中在一个地方是有好处的，就像我们真实世界所谓有条理的布局一样。   －－
  － 和函数式编程的固定输入输出一样（即变量不可以被重复赋值），把语境严格的划分在人类思
  维完全可以理解的范围内也是可行的。

* 人类思维是否都是完全等价的。即只要有足够的耐心和时间讲解，对方一定会明白，然后 TA 也
  可以这样讲解给第三者。类似计算机的 CPU 和 IO ，以及信息传递。

* 在代码文件布局上保持在每个层次上都有一个 self 。Java 里的目录命名空间也是一种方式。

* 世界是复杂而又简单的，这种复调同像性在世界各个远近高低都是。小孩子觉得世界简单，大人
  觉得世界复杂，小孩子觉得大人复杂，大人觉得小孩子简单。显著区别的人可以划分为有限数个
  (比如生物类属)，类似的可以有无穷多(比如一到无穷)。但是这一切其实只是人类思维使然而已。

* 逻辑以直观为基础。而直观是可以被灌输的，不管是经验, 或教训, 或推理。

* 真的是代码吗，体现的都是人类的思想。

* 源代码组织也是重要的，比如不能太杂乱。认为编译后代码一致，或者从最终输出出发是不够的。

* 取决于你目标的上限，hard 模式是综合速度最快的，远快于easy 模式。

* 编程让造物主从对象自身设计，七个器官，五个手指。而使用量和效果也是依据二八法则，比如
  人类依赖视觉远多于听觉触觉嗅觉等。大拇指和食指的组合占据了大部分。

* Human程序语言 导致的结果是程序在执行和语义上更适合被分层，便于调试，降低复杂度。


* 比如 Array API 的操作函数可能就十几二十几个，但是因为这些函数返回的还是 Array 就不觉
  得其复杂了，只是觉得简单的多而已。举个例子，流水账易于理解，正是因为内在逻辑的扁平型，
  而康德哲学难以理解，看了下一个段落，就忘了上一个段落，正是因为他指的概念之间及其错综
  复杂。

* 为什么仔细想好写代码比快速实现在综合情况下更好。因为人类理解概念是按层次和组建来划分
  的，仔细想好写代码就意味着这些原则，而快速实现是暴力地把一大堆想法直接压扁到纸上，唯
  一的原则就是快速而正确。所以快速实现只适合短跑项目，即一次性小任务。

* 美(艺术)是什么? 除了一些基本原则(比如黄金分割，复调呼应)外，好像无法从人类的思维特质里得到。


* 运行错误栈取决于你认为的底层位于哪条界限。一般编程语言位于自身，其上是库。

* 语言不是公式推理，它的功能不是说像lisp一样拥有最小语言特性就好了。而是为人类思维和逻辑
  之间提供方面的桥接以及生态系统。


软件工程
----------------------------------
* 程序员写代码时考虑的是以后别人如何来看这段代码，而不仅仅是符合业务逻辑的代码即可。
  这点和画家很像，考虑的是别人如何看。音乐和文字等时间性的东西就没怎么讲究，更多是考虑
  自己当时的审美。

* 最底层核心业务数据按照UI设计是可怕的。这说明的是直接纵向设计到底是不对的。

* 好代码的标准：1。三秒内明白这几行代码对于全局的作用。2，半分钟明白全局架构。两者都不
  用太知道其中原理。

* 在多层循环时，习惯给每层变量后面加数字，用于表明是归属于第几层的。个人代码习惯而已。


Questions vs Answers
----------------------------------
Q: 文学编程的优劣?

A: TODO

Q: 选择 CoffeeScript 作为试验 Human程序语言 的原因?

A: 1. 用空格缩进来表达程序语义，并且比同样采用空格的 Python 更简约和有表达力(比如多行
   lambda)。2. 作者 @jashkenas 支持文学编程。3. 非语法上强制，最终都可以编译到诸如
   JavaScript等语言。

   目前作者我对于实现编程语言还有足够理论和经验基础，不改变编程语言行为，而只约束编程规
   范，这样对于作者我或者用户来说，成本是相对最小的。而且基于 #Human程序语言的理念# ，
   程序语言的范式和语法和库等，都只是作为思维对象而存在的。

Q: Human程序语言 的理念。

A: Human程序语言最大的特点和优势就是在于革新了人们关于编程语言的观点。不再以穿插在各个
   层次的并导致混乱不可维护的代码为思考点，而是以人类的思维作为出发点， 人类只善于在一
   个上下文里自由地思维最多六七个对象。对于把程序实现作为目标的程序员来说，需要同时兼
   顾好程序各个层次，以及业务各个层次，调整和理清每个部分是至关重要的。

Q: 思维的本质。

A: 在我看来，思维和自我应该是等价的，首先想到的原因是自我必须或只能通过思维来确定自我
   存在。详细论证得从哲学和脑科学等多方面来研究。 TODO

Q: Human程序语言 到底是编程语言 还是软件工程法则?

A: 首先是一个软件工程法则，但是会让编程语言更有利于表达这一法则。所以可以现在其他编程
   语言上尽可能实现，在有足够经验或不好实现时，会逐渐构建起来自己的编程语言。

Q: 什么是最佳代码(和具体何种编程语言无关)?

A: 最佳代码就是意味着尽可能好的工程实现。对于对方提出的任何切实问题，都可以在视觉上很
   容易(几秒到几十秒不等, 等价于一般人类等待网页打开的时间)。也即是代码尽可能在各个层
   次解释。

Q: 软件工作者 可以留下什么?

A: 生产的软件不仅自足，还可以作其他续用。比如公司一个内部项目，分离出一个MVC框架，开
   源了，别人可以继续用和改进。

Plan
----------------------------------
* 用 CoffeeScript 来实现第一版 语法和语义验证器。 具体原因见 #选择 CoffeeScript 作为试验
  Human程序语言 的原因?# [20141026]

CoffeeScript
----------------------------------
* 好处是更让人觉得语法是为表达服务的，而且很容易理解不同形式的转换。


Human编程语言 设计草稿
----------------------------------
* 一个 **if** 里最多不得超过六七个条件
* **if** **else** 因为它的扁平型，是可以无限个的，但是一般用户也不会和没有条件这么做。
* 面向对象的根基是类。类可以把数据和行为捆绑起来，这样以数据为节点， 行为将它们连接起
  来，因此这样的本质性就是数据。函数式编程，或某些动态语言(比如 Python 把函数作为第
  一等公民) 把过程和数据同等强调，甚至可以修改自身，因而获得极大的灵活性。我意味函数
  就相当于故事。人类是用故事来理解世界的，评判一个人的好坏功过莫过于此。而故事是扁平
  化而易于理解的。
* 增加一段足够长度的注释就得一分。
* 概念越多，得分越高。但是同时也得排除概念的重复度或重复部分，这可能可以通过语义分析
  来得到，比如编译后的 JavaScript 。
* 既然是层次化，能否静动态混合类型编程呢，用于提速或安全等目的。一部分是机器码，一部
  分是类似JVM，一部分动态。
* 既然在每一个层次都是逻辑，那是否可以完全的加速呢，或者程序自己显示消耗出现在什么地
  方。
* http://www.alorelang.org/doc/typeoverview.html Alore is a programming language
  that supports both dynamic and static typing, and a mixture of both in the same
  program.
* 1.2.3.4.5 序列化编程应该融入编程语法。


Copied From Reminders And Stickes.
-----------------------------------------------
男人脱发睾丸酮软件开发。

代码写的像PPT

图灵测试自证的反驳。

发音是语言的回响。声音永远让位于图像。

程序表现是空间性的，而运行却是时间性的，很多人被思维运行方式而把程序写成时间性的了。复制意味着静止和同步，思考和写出的程序都是。

编程就好比教傻子做事，结构化编程非常有益。

并发好像和语言无关哦。

lisp遵循human是否可以，还得学会lisp再说。

mind是创造性的来源，也是毁灭性的来源。

编程是让人的思想在外部执行，当然执行规则得符合外部载体的规则。但是编程也仅仅是人类思维，它根本不是别的什么。人于外部确切沟通的方式只有逻辑？！或者只有逻辑才是确切的。

人们之间相信理由，这个缘由是什么呢？！

一切都是逻辑，数据是，函数是，区别是数据是被动的，函数是主动的。另外，函数因为数据而显示其自身，当然就计算机表示而言，他们是均等的。

同步编程就逻辑而言相比异步更简单（在多个事件之间要显示分离IO顺序），所以大脑会倾向于先忽略同步带来的CPU和IO之间使用率不均衡。

而世界运行的本质呢？可能得求教于物理或者哲学。

你不能根本了解世界和自我的运行本质，而只能经验型的接触。

闭包的本质是把数据（类）的地位让与函数，，也是how让位与what（how必须通过数据改变来体现，而what只是表达了一种声明式。

情感是一种时间性。

JavaScript里除了基本数据类型，就是对象和函数。而函数是带函数的对象，并且是原型继承。

维特根斯坦《哲学研究》第二页说的“拿5个苹果”在大脑中如何理解这句子里的三个概念“拿”，“5个”，“苹果”。而逻辑只在句子中，不在句子外，所以这三个概念机器理解不了，只能被定义着去模仿。

要求在一个段落里识别“too young to die"。假使 to 的 t 倒着了，因为已经识别了"too young"，概率很高，所以大脑试图纠正 倒着的 to ，以使其满足答案，这样其执行行为就超出了原始需求死板的定义，转而创造性的去发现其中规律，从而达到目的。

代码不应该拖累讲解速度。即脱离代码给别人解答具体相关问题的速度，结合代码讲应该更快些，而目标效果就是对方可以维护这相关代码。

敏捷等方法论，程序语言之争，项目工程管理，都已经成为宗教。而问题的本质就是人类思维，我觉得还是和人类思维本事死磕更好些，与自己和别人死磕。所以有句话说，问题的本质还是人。

因为计算机完全可以被人所控制，所以其中的“时间”也是被控制的。但是当人类面对其他未知事物，比如外太空，那必然得先抱着敬畏态度，并随时准备接受颠覆世界观的可能性。

从人为什么写作，到为什么必须得编程让计算机接受命令执行。

不只是逻辑，还有美感。

写程序过程中得及时更新关系图，为单层声明，表示为JSON（以后可以作可视化分析）。如果是多对多，把关系类作为键。主要目的还是为了方便程序分析。类应该是大写。所有程序中用到的类必须在JSON里声明。这一切都是为了快速理解和清晰。这样一定意义上可以促进动态类型语言有静态化，便于类型推导。

函数（即过程）和类可以合并为一个概念，这点参考JavaScript。

可选。类也有版本的概念。包括其中数据和行为。

基本数据类型是指可以通过01进行逻辑变换得到的。

软件工程毕竟还是一个完全在人类日常经验范围内的。

UML 为什么失败？！http://www.cnblogs.com/shuhari/archive/2009/07/01/uml_is_failure.html

人的思维几千年，几百万年有进化吗？好像没有。

上下文的定义取决于一般人类思维能力。

编程语言依赖的作业环境应该不依赖于 编辑器或IDE。

互联网快速开发实现是以牺牲远见为代价的。

人类说话类似于机器码执行，任何人的表达于TA当时的判断在速度上于TA的能力是最快的，但却可能不是最符合对方的接受执行能力。因此，人又是可以判断对方接受能力或层次，调整自己的表达。

非也。人类可以正交或重复组合各层次概念，以补全对方的理解层次。

维特根斯坦在《哲学研究》序中把札记比作风景画。

人类思维本质在于它是当下的，它是被神秘力量驱动，而自身却不知道。不同人类思维之间只有通过感官沟通进行交流，而本质都是为了维持神秘力量的沟通需求。

具备改变能力的思维生产和消费行为，所以世界是行为主导的，函数式编程把持久化数据弱化为内部状态。

时间是人之间思维得以同步的方式，比如约会，上班。


意识区分出内外。

当面对达芬奇的油画蒙娜丽莎时被要求说出第一感觉，众人按自己审美反馈说神秘，微笑，端庄等，不过数个形容词概念，它们都是一种综合。当面对倾倒出的垃圾桶时被要求说出感觉时，无从规律而言，只反映说混乱。

发散性思维要求对日常经验的思维过程涉及到的概念进行审慎。

医学不可能根治是因为疾病和思维一样，是本质性的，是一种人类无法理解的驱动。中药西药只是从万物关系里调剂而已。所以比如心理问题是本质的，引导为主。

《时间的观念》P168。柏格森。时间意味着创造，意味着对历史的回顾，意味着调整，意味着审美。当代计算机程序的自省依赖于创造人的调整。所以可能还是得归结到自由意志的问题。

现在意味着自我。

目前我对编程本质的体系化可以类比于古希腊哲学的开端。

人们通过时间性联系在一起，即所谓时过境迁。人以群分通过上下文或语境相似联系在一起。家族的血统通过人的向死而生延续着。

链接后的语法树雷同于Human编程语言，但过程和结果还是值得我研究。

眼睛视觉和思维视觉，孰先孰后。

explain编程语言。编程就是教一个傻子做事，不断的解释。

DSL的伟大之处就是在于单一职责，局部性，以及线性故事性。


对计算机来说，talk is explain.

human翻译成Python代码，就像CoffeeScript翻译成JavaScript一样。但是得注意是否可以一一映射，而且Python是否优点够齐全。JavaScript主要是事件驱动太强不合适。

人不能同时思考两件事情意味着上下文。

费曼，总想逃避，这一张，讲了大脑和身体探索。

思维是内在联系的，比如网状的，如果意味着神经细胞消息传递速度，人类体能是类似的。

语言是思维形式。编程语言阻隔日常思维，专业领域，这个事得弄明白。

计算机可不可以实现，意味着可否映射和复制，比如硬件API。情感无法映射，所以替代不了。计算机无法替我们吃饭，做爱，大便。

因果关系意味着简化，来自《逻辑思维》活得明白。判断意味着主体，意味着判断。

梦里用的是另一段记忆区，所以梦里还有以梦。

人的精神本质在DNA里吗？

talk is cheap，show me the code。意味着核心思想可以剥离，最终结构的生成以及平衡等都得益于功力。

linus 指的数据结构及其关联比算法重要其实是针对 数据持久化的项目来说的，也许不完全是。

写完代码，但是一般来说一定不完全正确，还得调试，这就是人类上下文的局限。

Linus 说，计算机科学和物理一样，都是在一个非常基础的层面，探讨整个学科的运作原理。66页。

在有经验的前提下，审美是首位的，敏捷和解决方法的出现其次。和晓光讨论JsonUtils.unicode_dump有感。

既然大脑分多个区域，那为什么人基本只能同时想一件事情呢，除非变成躯体运动。

编程语言设计核心要义是以相对上下文为中心，辅助以各个概念层次。应该不是基于机器学习的统计来，而是显示的固定规定。或者当前项目自身，或者经验统计。

我始终觉得不必完全在意别人的看法，只要自己觉得可以相信自己能领导自己就可以了，而不是把全盘把自己交给整个社会体系。

群体智慧不是投票，而是每个人都有自己的主见。

在项目的不同编程阶段，人是会遗忘的。对概念和概念关系加以拓展和进化。这也类似于众包的维基百科。

我有这么多开源项目，以精简复用的形式表达。

人的理解总是合理的，所以理解存在是好的。

世界不是真这么简单，或简洁，而是一定要在这个领域层次理解的话，定义出来的规则只能这样。如果规则还能解释或预见更多事实的话，它只能说明理论到目前为止还是可靠的（只能在自身理论里自足），但是却无法解释更多理论外的东西，比如相对论介绍不了物理层面之外的事物，如音乐，艺术等。所以人类的本质和未来就是内心而已。

为什么你的个人大脑占据的这部分空间必须可以理解其他所有空间呢，包括与你类似大脑的许多空间。理解是大脑的独特机制。

对一个编程低手说，即使你的程序达不到优美，但至少应该清晰。虽然清晰和优美同样难。Java是否完成这一任务呢，没有，在犯错上强制了点而已。

我的朴素直觉，别人的系统知识，并没有本质区别。

生命和思维之间的关系。狗是如何识别出主人的手，而不将其吃掉，是因为经验和遗传吗。

识别不是自上而下，或者自下而上，而是整体，整体意味着注意力，即上下文。视觉从视野里分离出主体的汽车。

计算机模仿大脑架构。一切都是源于模仿世界，挖掘意识的背后。

视觉，听觉，触觉，嗅觉，味觉，空间感，思维自我。一共七个。短时记忆为七个。

编程是思维的跳跃组织。

长时记忆是视觉，短期记忆是听觉（156页）。我和女朋友出来，记得路上发生事情图景的前后次序和细节，至于听觉，只有特别印象的才有，比如服务员问我点了什么冰激凌。想想昨天和连华俊晨聊了什么，只有零星的整理概念，比如音乐爱好，点菜细节。短期记忆是听觉可能就是因为我们生命的时间性。

接上条。所有难以维护和理解的代码是听觉记忆。好的是视觉记忆。之前我把编程比拟为绘画即是如此。

小说的艺术在于呈现什么，古时不带凸显主题组织的流水账。侦探小说在于整体，一个一个抖包袱，包袱包袱相互串联，最后形成整体，真相大白。

可阅读的文字是视觉和听觉的结合，短期记忆和长期记忆的结合，考验人脑思维组织的技艺。

连华说我的内存小，理解周报告家长端。因为我和别人沟通经验不足，更多是视觉思维。别人是听觉思维。所以在长时记忆里我胜出。

符号编码连接视觉和听觉。

建议编程都切换到更有利的视觉模式。

解释给别人听，意味着短时记忆，即听觉。但是东西一多，杂乱，就不行了。

事件编程是手工指定异步IO，其实应该可以自动的。过程式是短期记忆。面向对象是带状态转移的过程式编程。函数式编程加快上下文切换（curry），确定性。

在大脑为解密之前，如爱因斯坦说，不可理解的在于它是可以理解的。

Java的强制异常检查错的地方在于不能把它和其他东西分离开来，这样是一种混乱和干扰。所以我更期待可以在任何层次和区域分离的模式匹配。

前端在于它的被限制性，重置性。按业务场景（人类交互）分离是很正常的。前端更像现实世界，服务器端只有通过各种接口机制更多，即数据。很少直接去操作服务器内部细节。从业务整体角度看，它只处理了前端部分。静态页面由后端处理逻辑，单页应用则承担半壁江山（中学题库）。

而创造力和视觉听觉模式无关，我还没有想。创造力是在一定时间里专注才能有的。

美好食物虽然与思想无直接相关，却是思想的养料。

被项目后来者理解，代码必须转为长时记忆模式。

康德哲学难读的短时记忆？

创造是长时和短时记忆的混合。讲故事是长时记忆，可能是。

伟大的作品，就风格来说，必然是个人的，就实用来说，比如是世界的。

性感的Human编程语言。应该是。

短时记忆的创造只有变成长时记忆模式才能被大众接受。

编程更多在于长时思考，所以敲键盘是不需要快的。

长时图形记忆是短期的整合，升级版。

优化不意味着难以维护性，只是因为发觉了业务内在更多的复杂性。如果还是听觉，那就难以维护了。所以得用视觉。

听觉和视觉唯一可以相互转化的只有符号。

因为javascript只有一个CPU，所有代码是同步的，而IO不同步。假如js多进程，多线程，问题就多了，得函数式编程了。现实世界却没有问题，真奇怪呀！所以问题就出现在人类大脑的单CPU性，上下文切换乱了。现实世界对我们来说真的是个谜啊。

大脑和大脑不能融合，意识不能直接对话。意识的本质，存在，自我，保存，海德格尔的持存。自我真的是个谜。



对我们来说，对大自然进行改造或破坏，对于自我是没有影响的，主体和客体。

说下自己教育背景，退学等。

阅读尼采，仿佛参观一个疯人院。


听音乐的身体颤动共鸣源于音乐的易逝性，生命消逝短暂，死亡恐惧。希特勒演讲。

当自我遇上了自我真是麻烦，遇到他人时因为自我的单CPU性才能保持一个自我。


CPS和human编程语言。human强制数量，可能得引入CPS。

函数式里用CPS递归方式实现for循环，避免变量赋值或重写。

视觉有模式（思维会从中找模式），而头脑里的一堆概念无法找模式，所以有数学家用图像思考。





梦是被四处乱扔的记忆或经历。睡眠时，大脑CPU回到梦区，所以重复梦，或者潜意识最近在想的深刻，渗透到梦区。可以看看睡眠时，大脑哪些区域还活跃着。

计算机的抽象和我们展现了人类的思想可以有多少抽象层次，和物理学等学科有多少类似，但是其根基确实逻辑和二进制，而科学的根基我们却不知。或许计算机的根基是思维本身，而思维的根基就是另外的哲学神学美学问题了。

代码即你的思想，所以没有重复。

口腔溃疡，眼睛，身体累，上班远，明白人生。

晓海，架构师，讲给我一样明白。

一切皆上下文。Human 编程语言也是一个上下文。

human编程语言关键字“what，why，how”？后面加说明字符串？注释自动匹配到最相近的代码，如相同则警告。

内省。statlysis, 阳光书屋。

代码最好具有不细看也知道做什么用的特点，适当的注释和布局。

去各拖沓机关办事的事宜。

http://rubby-lang.org/

连华适龄数学教育，人思想在睡眠时不一样的，用脑电波对大脑的数学部分进行自动训练，就学会了。

听一般主题演讲，听众觉得很有收获，大部分人是总结了大概和个别句子，专业人士会两方面更多。原因是听觉记忆导致。感染力是听觉的艺术。

可以说出混乱的标准，超过六七个，找不出模式，却找不出美的标准。

和一般编程语言有一样的Object基类，但是名字换成Context。属性可以任意多，但是行为最多七个。考虑一下原型继承。

上下文意味着没有继承，只有连接。递归是概念内部的，或者上下文内的，所以应该不会太复杂。

给一个上下文理解，而不是一堆Object。上下文就是解释。

声明式的SQL是一套限制型的逻辑范式。

二分查找的递归是生成新列表，迭代是范围值缩小。

上下文不是思维的某种形式，而是思维的本质。其驱动者是自由意志。

因为你知道这个上下文用来做什么，所有你确定应该返回什么。多类型，或不确定类型（但知道这是我们已经定义过的，比如GSON），或者动态新建一个Context（？）。那所有上下文位置你应该都是可以找到的，如果存在但是找不到，那就新建一个了。

上下文，类，对象。复用算是什么？

区分只是在上下文内部，上下文本来就是独一无二的，否则没必要创建一个新的上下文。

上下文本身是个上下文，它也理解不了上下文以外的东西，所有上下文理论是自证的。

举例ActiveRecord的类定义里有scheme和方法等，两者可以分开为两个上下文，但是可以像Ruby传统里可以直接调用，或者另外一个关键字（多个平行上下文就看顺序排列优先级）。得有关键字来做平行定义，说上下文a平行于上下文b。

VIM分屏就是展现当前编程人员涉及到的上下文。

human的包机制和python的import语句应该差不多，但是托管机制还是和ruby和node类似吧。

human虚拟机执行和Luigi类似，有向无环图。当然也一样可以做视觉化展现，无论是当前项目还是整个VM。其实就是命名空间。

Context也是可以run的。是否参考Python用两下划线表示内部呢。这样就支持函数式编程了。

Python里的关键字class和lambda,在这边都用context表示。没有Context，所有默认继承于此。或者和Python一样有没object都可以，但是会少了object属性们。如果是Ruby，所有都是Object，加上面向对象，那就可以方便进行5.week.ago这种链式调用了。

过多使用听觉记忆，长时间编程，导致脱发。而设计师不会。

大屏意味着视觉化，IDE也是，但是IDE太复杂？！或者不是真正编码想要的视觉化。

human编程语言版权？

《重构》里推荐一点点重构正是“人类上下文局限”的体现

听觉记忆正是上帝模式，所以所有创造性来自于顿悟。图像只是助于理解。但是人不可能随时和换人去达到上帝模式。

python的__slots__设计如何？

human语言里定义的所有上下文意味着显示了项目的复杂度的绝对性。

有上下文后，信息足够简明，是否可以做到对大部分进行类型推导了？！

Ruby的面向对象，上下文，括号省略，block等 很适合DSL。这个符合DSL的阅读习惯。

基本类型就是维基百科标准名字，比如Integer(__size__),String（unicode)，Array（array,list),List,Stack , Hash(linked,sorted)，Bool,，这样API不变，单还是可以用几个基本类型来思考。Array可以声明元素是否一个类型，声明了就不可以变了，反序列化会检查这些值（类名和__type__一致，其实这两个组合已经覆盖绝大部分情况了吧？）。

接上面，一个Context里，和Python类似，首先__id__，__hash__,__type__,等。

__type__里包含了默认属性，所以这个是在另一个context里定义的，没有就用默认的。

__type__赋值的是String，比如“list”。

Human语言虽然是动态语言，但是因为Context限制，所以鼓励静态化类型信息了。

一个Context可以有多种__type__，这多个types的数据是相互映射的（说错了，大小整数就不可以，只能说一部分可以转到另一部分而不会发生改变），既可以一一转化，比如最简单的是Array和List和Stack。但是它们之间函数个数和名字可以不同。

自定义类比如表示一个长方形，宽和高，惰性属性面积。

函数和数据如何转换？Python有property把函数转为属性。

Python做错了，点就表示调用执行了，如果看定义，比如通过__dict__看本来是什么，或者从类里面看。我刚从Ruby转过来接触Python，对方法必须加括号才能执行表示不适应。

动态属性如何实现？Ruby里有method_missing。直接定义一个__missing__属性函数。关键是这个missing也得由context实现才能统一概念。

语言异常？类型检查我们一定程度上有了。todo

__type__就多了一个概念啊，在继承时无法指定哪种Array。todo

没有上下文限制导致概念间的误解，比如函数调用开销大。

一个对象.context(函数名或属性名）返回那个context，属性可以认为是函数的直接返回，即类是函数，new之后直接返回就是基本类型数据。

每个context有一个HTTP URL地址。

Ruby语言的缺陷，缺乏命名空间，这点Python好。但是Python的类和实例没用大小写区分也是遗憾，当然一个类new之后也可以返回类。

异常的本质是，是可以预见的吗？！

避免继承，鼓励组合。所以Ruby的mixin module在这里变为.__type__和.type("feature")。相当于用形容词实现。实现多个上下文一起思考，也好像变成了易于理解的自然语言描述。相当于存储引擎改了，可是我们就直接创建MySQL表使用，约定大于配置。这样不是一颗树继承（不鼓励太深继承），而是可以向前向后联结。

和人类社会和个体一样，一个事面向一个主体。虚拟机审视代码逻辑依赖启动，如果没有并发，就等价于传统单进程执行。执行流程可以被审视，在human里，和Hadoop等分布式一样，可以把一些动态context注册，即是它们会出错，有栈。而一些很固定的，它们不会出错，出错也是它们可以预见的。会出错的就得注册。

音乐，即时记忆，激动。绘画不会。

state monad

顿悟是上下文之间贯通，形成直觉的过程。

在ruby聚会，吕神和另一人反对一定是确切的七个，说不应该阻拦。

懂很多和未知原理的上下文是一件刻苦的事，所以初中对前端blocks式架构超出经验范围有点诧异，但是因为能work和并非完全不可懂而接受。另外jQuery实际上是一套声明式DSL，已经无缝融入JavaScript了，所以用户接受了。

上下文是人类理解思维的，所以是一直不可完备的，上帝的才是完备的。

数学是人类理解里属于看上去简约的一类知识，所以面对数学无穷问题更容易暴露出来，事实上涉及这些都是不可能穷尽该问题的。唯一可做的是和叔本华说的一样，在审美创作中麻痹度过，无法停止的欲望，直到死亡。

turing说，“合理性的证明依赖于人类记忆的有限性”。

以有限性去推断无限性是不可能的，人类思维是无限和未知的（背后的机制），所以人工智能是不可能的。虽然一定程度上可能，但是规则还是太复杂了。即世界不是由相对论或某几个基础定律等所决定的。


中文房间很扯淡，汉语和英语在一定程度上是可等价的，而且背后的思维会去引导和意会两者联结。

《图灵的秘密》330页。约翰卢卡斯说机器容易计算，但是不能运行元数学。元数学没有定义哦，我认为他指的是思维。

形容词可以展现对象的多面性。以及思索的更多可能性，挖掘其内在未知。

用infer，表示某Hash是啥类型type，比如linked。

概念不是上下文，而是体系，是上下文的一个直观。正想爱因斯坦的相对论公式，每一个都需要更多的解释。其他公式也是如此。

不要for循环式的列表推导，而是用形容词列表依次处理。for遍历容易多层混淆。如果多个形容词，也即是循环类型的上下文，可以知道自己在第几层，并用类似_1，_2，的方式引用上层，或者指定引用哪个循环上下文。这样也有利于扁平式。

for循环在七个限制里结构优先。

细节局部都懂，难懂的是整体直观。

文学化编程文档注释多，代码被缩进夹在其中，其实就是上下文的体现。

json键值并列赋值就是扁平化，但是也要考虑内部的上下依赖。

每个上下文都得至少一个注释，即使是个空格。也即是“文学编程”。

编程就是思考，思考就是上下文。

遗忘测试。在三个月后看代码。

"类“正是一种模式识别或匹配。

形容词用Ruby的symbol表示，其实也是类似于协议，但是也包含实现。

限制性的明确解释。

美体现在内聚性，这和上下文相辅相成，包括不同原子或上下文摆放体现的美感和内在逻辑。

可以多于七个，但是必须使用序数注解。

科技的显式力量尤为强大，就像男人力量大过女人。

编程本来是数学优先的，可是在实际做事上还是听觉记忆占优，所以命令式为主流。可是编程大师已经融合函数式＋命令式＋。。。了。

长尾只是因为上下文。包括二八定律。正态分布。字符频率定理。等等。

人与人之间千差万别，除了人的复杂性外，用于理解区别的各种上下文也是关键，因为我们对于上下文是如此熟悉。

理解就是变成直觉？！ 然而直觉是可以遗忘的。

从效果出发，把次要元素去除，类似计算机不同层次的IO，从而得出定律，这全是上下文的功劳。

解释就是经验的上下文。

公司架构和部门和职位即是上下文。

思考快速眨眼，可能是来自远古需要细察周遭环境而进化出的特征，依赖于视觉模式。或者思考时看着空白的天花板。

从上下文走到上下文，别人验收软件另一个上下文。从耶鲁《死亡》想到听觉作为说服的艺术。

git commit 细粒度的上下文思想。

领域无法解释不同领域之间类比的现实。所以上下文更确切。

爱因斯坦文集一。567页。《关于数学领域的创造心理》。他用视觉和动觉，用肌肉。语词出现时才纯粹是听觉的。所以编程和敲击键盘一起才变成听觉的，这个技巧很难把握。编程提前思考意味着视觉更多。

视觉编程应具备符号DSL的能力，譬如函数式语法，所以符号在可视化上很关键。matz最近设计的streems即是。

好的幻灯片完美的展现了谈话的重点和上下文。

为什么可以修改IO而不能修改CPU呢，因为修改了CPU即是把CPU当作IO了。

人脑里的数学计算其实是图形化的直观。还有训练为肌肉记忆。

肌肉记忆，视觉记忆，听见记忆，三者在思维中混淆。常见于游戏中。

@ 既是 doc, 也是 decorator。

在没写完代码前，认为任务简单，正是因为上下文机制。即使明白者，也认为多花时间别人和自己就会理解，实际上都高估了。可是这附加和隐蔽的上下文藏在哪里，可否通过逻辑等手段推断出呢。答案是不能，因为上下文是人类理解的形式，形式为直观和超逻辑和美感等所创造和推动。上下文内在才是逻辑的。

通俗讲解即是把专业术语的上下文放入接受者熟悉的上下文（通常是日常经验），在一个上下文里，置换一个（或者二个）即可。这样别人就理解了。

Ruby里的module加上限制后其实就等价于human里的形容词。

生命才有上下文，即需要一个head。而无生命体不需要。没有思想，就没有重点，缺乏凝聚的重点，比如岩石等。

额外性意味着杂质，意外，无意义，和主体上下文的关系很微妙。

思考是用短时记忆来处理长时记忆，短时记忆是用来被遗忘的。

GC和上下文结合在一起，可以实现局部回收。每一个上下文需要给出一个自足语义。

快速编写程序应该属于DSL，否则应该构建完备上下文架构。

长时记忆是一种上下文的记忆。

数据是用来看的，逻辑是用来理解的。

人类的解释是最迷人的东西！

直指计算机科学和编程的核心问题！

方面，层次。横，纵。

算法的难以理解，正是因为其复杂度太高了，所以更需要上下文编程。

如果精妙算是代码之美的话，那什么是精妙？

面向理解编程。

上帝关注显露，人类关注理解。

程序的复杂性证明了简单的东西组合后不一定简单。简单的只有直观的东西。

《没有时间的世界》，他们三个借由对思想与实在界的设限，来体现出时代精神与当代思潮。

概率论是上下文体现出的另一个角度。这个世界有本质，在人类的上下文看来体现为概率。也许公式就是概率的某种极致。

69页。乔姆斯基，重视语法超过语义。对语法的重视（繁琐或矛盾的细节），导致程序的复杂性。所以上下文编程重点正是把重点放回语义的本源，并以此展开，这样就不会被逻辑控制。

限制是对堕落的制衡，对内心的平衡，上下文思考的辅助。

视觉站在思想前方。

美好的事物是各种感官都可以感知到的。比如一个美好的房间，你可以想象到味道。超越感官的。

在human里体现丢弃的概念，即封装成某一个层次，机器码，字节码，程序代码，等。但是现在语言只有程序代码一个层次，否则就得多语言混用，比如Ruby的C扩展。

接上面。其实不需要这么多出错栈，只要对应的局部即可。

程序都应该知道当前在哪个上下文，比如函数内部也应该知道。这样比如递归就不需要还是本来名字了。当然函数内部的栈就对一个对当前函数引用了。

REST的优势其实就是上下文吗，接口不会一团乱。

训练抽象思考。主动发现美。

Human某部分静态，即@static, 就是真的是二进制静态语言的，同时就要求参数类型确定了。

loop实例化，并变成闭包。while同。

每个context里最多包含7个context，除非序数编号。loop，while都是context。

形容词变成symbol，这样不必引用类了。在参数传入时限制行为。

任何类型都是上下文，甚至字符串，整数。只是这些整数被编译为静态的而已。

组合对象技术，比如Rails里的6.weeks.ago。并不是方法链级调用，而是组合才发生这种可能性。这样避免复写6.weeks.ago。这是更强大的组合式思考上下文。最后多加一个点表示是句子，从而组合。   Rails里看着简单，实现复杂，记忆规则也负责。组合就简单，符合人类思维，在组合里，小写自动解释symbol。

有些是符号，有些是对象（考虑类型）。

所有词法是静态的，那该上下文就是静态的。

on关键字，取决值。

代码排列应该尽量交给编程语言，可以自动检测的。

组合 前面其实也需要.的，但是如果是语句开始，一般就省略了。或者是homework..day_limit.days.ago. 。找个更好的例子TODO。

人类语言肯定不是机器语言，因为隐含了太多经验（上下文）。

不要关键字new，而是 book1 = 1.Book(name:圣经)。这样更符合日常直观，而采用的是组合模式。

for 循环等 其中的变量名必须以数字结尾。

俊晨说的 luigi 极大地改善了代码复杂度。我现在认为是因为其中提取了内部逻辑的内省。递归只是函数级别的，效果还比不上类组织（以IO为基础）。

于是类名是否支持复数形式呢，我认为应该在 组合 这一层次上解决，纳入标准库。复数其实不强制。

因为语言交与别人理解，所以说得必须可以被理解。而程序不尽然是，只要有限严格语法对即可。

对于程序，不是部分组成整体，而是整体拥有部分。即整体大于合成的部分，其实任何事物都是这样，因为上下文总是可以展开的，待发现的。这说明了人类思维的局限和特点。

并没有简单和复杂之分，只是因为上下文。不过直觉和记忆是很神奇的。

取消继承，和Haskell一样（待确认）。最初随意指定一个对象就是Nil，即从虚无中来。当添加一些东西后，比如组合，就不再是Nil了。

人类世界其实没有继承，继承是思维构造出了的，抽象了事物。其实现实世界的进化是组合和创造而来的。

@表示装饰，$表示资产。

整体论或还原论本质就是人类思维有限上下文体现的两面。一面是分解，一面是意义。上下文就是时间的来源，时间联系了所有人的思维。

软件架构正是慢速思考的体现，思索每个角落，灵感出一个方案。

谈话有时比文档架构图表更好懂的原因是有个上下文清理。

因为生命原理是上下文，那么生命的认识原理也是上下文。

程序员三大美德之一暴躁是因为设计程序需要集中精力，外人不能中途打扰。

on关键字替换,loop,for,while 等。两个for循环，第一层两个变量，第二尝遍历第一层第二个变量，并和第一层第一个变量相乘，得到一个总数。

如果变量仅在一处作用域使用，推荐放入该作用于。或者该变量是外部某一对象的属性。

字面量均通过.结束来返回具体对象，字面量仅仅作为概念，但不是对象。这样通过组合就可以了。

对具体命名的变量的每个操作，都记录引用，这样这个变量就不能轻易改变值或类型。

method作为公用函数，而len才是Array方法或属性。如果是类似Python的__dict__也应该用公共函数取。可理解可读可划分永远是第一位的。

内省是解决软件复杂度的中心，所以在各个层次上思考why，what，how。

时间的共时性是不是等同于人类理解？

时间让上下文成为可能，也让叙述变得理解。

梦的无声即是证明大脑以视觉为主。补: 换到梦里去了。

得到确信就是理解。

触觉感知形状和温度。

human编程语言作为整体和01逻辑并不等价，虽然运行于之上。但是就像油画和画布不等价一样，人解释一样的才是等价的。已经差的太多了。

可视化理由之一：俊晨grep的数据源出错。指错了。

类本来就是抽象的，所以何来类方法的意义。所以应该取消类方法，类只用于组合。

组合的模式定义不需要动态化，因为其本身就是动态的。

首先明白在管理依赖这个业务里，编程比UI强大，UI是由编程API构建出来的。所以两者不矛盾，也不存在难维护的问题，唯一区别是UI比纯粹编程多了可视化操作的功能。

调研 DHH 是如何写 Rails 的。

框架是从业务中逐渐抽取出来的。即是不能脱离具体业务，就直接写出一个能通用和完美解决问题的方案。一般而言，软件架构师是在完成具体项目时，就顺手完成了一个框架。或者换一种方式，框架的测试（包含测试业务案例）也是跟着业务开发的。  所以软件架构师带头写代码是必须的。另外还有几种架构师，技术架构师是对一种以上的技术体系非常熟悉，而且能和业务结合起来，这可能不太写代码。运维架构师，项目经理就不说了。

任何框架（包括编程语言）都有至少一种核心理念，且是内省的，即是指导的原则，也是逻辑结构。

思维不等同于语言的简单证明。感受到美，却无法用言辞表达。词穷了，但在思索。

程序语言是用来描述思维的，人类语言也可以用来描述思维，所以人们在思考等价性。不过人类语言可以辅助程序语言。

编程语言的核心从思维出发，其次需求，逻辑，美学，等。

人工智能的矛盾在于，加入有了人工智能后（即和人类一样智慧和情感），那时候还需要编程吗。核心就是人类的思维即是需求和存在，没有人类，智能就毫无意义。

人体对称性是神的智慧的结晶。和体现。

代码和缺点一样，自己的远比他人的能容忍。甚至自己缺点也要怪罪对方优点。

鼓励使用组合多过函数属性，组合其实在二元函数上又多了一层内省结构。




参考
-----------------------------------------------
* [《编写可读代码的艺术》](http://book.douban.com/subject/10797189/)
* [《计算机程序的构造和解释》](http://book.douban.com/subject/1148282/)

* [软件工程主题列表](http://zh.wikipedia.org/wiki/软件工程主题列表)
* [反面模式](http://zh.wikipedia.org/wiki/反面模式)

* [《认知心理学》](http://book.douban.com/subject/3171969/)


Copyright
-----------------------------------------------
@mvj3 (David Chen)
